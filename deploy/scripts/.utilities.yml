# Subroutines for deployment

# Sets standard vars and generates VERSION_TAG for dev/staging
# Tag format:
#   - image tag format: "1.5.3"
#   - GitLab release format: "v1.5.3"
#   - app git tag format (feature/main branch): "v1.5.3-c7754fc6"
#   - app git tag format (release branch): "v1.5.3"

.set_build_envs:
  image: alpine/git:latest
  script:
    - |
      if [[ -n "$CI_COMMIT_TAG" ]]; then
        GIT_TAG="$CI_COMMIT_TAG"
        IMAGE_TAG="$(echo $GIT_TAG | sed 's/^v//')"

        echo -e " \
          \nProduction BUILD_ENV detected.
          \n  - Setting GIT_TAG to $GIT_TAG \
          \n  - Setting IMAGE_TAG to $IMAGE_TAG \
          \n"
      elseif [[ -n "git rev-list --tags" ]]; then
        GIT_TAG="$(git describe --tags $(git rev-list --tags --max-count=1))-$CI_COMMIT_SHORT_SHA"
        IMAGE_TAG="$CI_COMMIT_SHORT_SHA"
      else
        GIT_TAG="0"
        IMAGE_TAG="$CI_COMMIT_SHORT_SHA"
      fi

      echo -e "\nGIT_TAG=$GIT_TAG\
        \nIMAGE_TAG=$IMAGE_TAG\
        \nBUILD_HASH=$CI_COMMIT_SHA\
        \nBUILD_SHORT_SHA=$CI_COMMIT_SHORT_SHA" \
        \
        >> .env

      # Sanitize envs (necessary?)
      #echo -e "$(cat .env | sed -e 's/\"/\\"/' -e 's/"$/\\"/')" \
      #  \
      #  > .env

      # Store variables for later jobs
      cp .env build_envs.env

      if [[ "$PIPELINE_DEBUG" == "true" ]]; then
        echo -e " \
          \n\e[31m##### build_envs.env contents: #####\e[0m \
          \n"
        cat build_envs.env
      fi
  tags:
    - production
  artifacts:
    reports:
      dotenv: build_envs.env

# Configures cluster name
#   - vars defined here are not available for GitLab `environment` definitions
#   - currently limited to:
#       - "dev-cp"
#       - "dev-vsm"
# Please note: Secret names correspond to certificate SAN's (eg. star-dev-ltc-bcit-ca protects `*.dev.ltc.bcit.ca`)
.set_deploy_envs:
  script:
    - |
      if  [[ $CLUSTER_NAME == "dev-cp" ]] && [[ "$BUILD_ENV" == "dev" ]]; then

          CI_HOST="$DEV_HOST"
          NAMESPACE_NAME="$CI_COMMIT_REF_SLUG"
          CLUSTER_ID="$RANCHER_DEV_CP_CLUSTER_ID"
          PROJECT_ID="$RANCHER_DEV_CP_DEFAULT_PROJECT_ID"
          TLS_SECRET_NAME="secret not used in dev environment"

      elif [[ $CLUSTER_NAME == "dev-vsm" ]] && [[ "$BUILD_ENV" == "dev" ]]; then

          CI_HOST="$DEV_HOST"
          NAMESPACE_NAME="$CI_COMMIT_REF_SLUG"
          CLUSTER_ID="$RANCHER_DEV_VSM_CLUSTER_ID"
          PROJECT_ID="$RANCHER_DEV_VSM_DEFAULT_PROJECT_ID"
          TLS_SECRET_NAME="secret not used in dev environment"

      elif [[ "$BUILD_ENV" == "staging" ]]; then

          CI_HOST="$STAGING_HOST"
          NAMESPACE_NAME="$CI_PROJECT_NAME"
          CLUSTER_ID="$RANCHER_STAGING_CLUSTER_ID"
          PROJECT_ID="$RANCHER_STAGING_DEFAULT_PROJECT_ID"
          TLS_SECRET_NAME="star-dev-ltc-bcit-ca"

      elif [[ "$BUILD_ENV" == "prod" ]]; then

          CI_HOST="$PROD_HOST"
          NAMESPACE_NAME="$CI_PROJECT_NAME"
          CLUSTER_ID="$RANCHER_PROD_CLUSTER_ID"
          PROJECT_ID="$RANCHER_PROD_DEFAULT_PROJECT_ID"
          TLS_SECRET_NAME="star-dev-ltc-bcit-ca"
      else
          echo -e " \
            \$BUILD_ENV is not set correctly \
            \n"
          exit 1
      fi

      if [[ -n "$PROD_NAMESPACE" ]] && ( [[ "$BUILD_ENV" == "staging" ]] || [[ "$BUILD_ENV" == "prod" ]] ); then
          NAMESPACE_NAME="$PROD_NAMESPACE"
          echo -e " \
            \nPROD_NAMESPACE variable detected. \
            \n  - Setting NAMESPACE_NAME to $NAMESPACE_NAME \
            \n"
      fi

      echo -e "\nCLUSTER_NAME=$CLUSTER_NAME\
        \nBUILD_ENV=$BUILD_ENV\
        \nCI_HOST=$CI_HOST\
        \nNAMESPACE_NAME=$NAMESPACE_NAME\
        \nCLUSTER_ID=$CLUSTER_ID\
        \nPROJECT_ID=$PROJECT_ID\
        \nTLS_SECRET_NAME=$TLS_SECRET_NAME"\
        \
        > deploy_envs.env
  artifacts:
    reports:
      dotenv: deploy_envs.env


# Creates a namespace annotation to ensure it's visible in the Rancher Default project
.replace_namespace:
  script:
    - |
      # Replace `namespace.yaml` entirely with branch name
      echo -e " \
        \napiVersion: v1 \
        \nkind: Namespace \
        \nmetadata: \
        \n  name: $NAMESPACE_NAME \
        \n  annotations: \
        \n    field.cattle.io/projectId: \"$CLUSTER_ID:$PROJECT_ID\" \
        \n" \
        \
        > deploy/overlays/$BUILD_ENV/namespace.yaml
      
      if [[ "$PIPELINE_DEBUG" == "true" ]]; then
        echo -e " \
          \n\e[31m##### Updated namespace file: #####\e[0m \
          \n"
        cat deploy/overlays/$BUILD_ENV/namespace.yaml
      fi

      # Patch `kustomization.yaml` with new namespace value
      echo -e "$(cat deploy/overlays/$BUILD_ENV/kustomization.yaml | sed "s/namespace:.*/namespace: $NAMESPACE_NAME/g")" \
        \
        > deploy/overlays/$BUILD_ENV/kustomization.yaml

      echo -e " \
        \nNamespace patch added to kustomization \
        \n"

      if [[ "$PIPELINE_DEBUG" == "true" ]]; then
        echo -e " \
          \n\e[31m##### Patched kustomization file: #####\e[0m \
          \n"
        cat deploy/overlays/$BUILD_ENV/kustomization.yaml
      fi


# Creates deployment annotations that mirror image labels that can be injected into the kubernetes resource
# Please note:
#   - `path_name` and `cluster_name` are only added as annotations to the kubernetes resource
#   - `title` and `description` are only added as labels to the image
.patch_deployment:
  script:
    - |
      echo -e " \
        \npatches: \
        \n  - patch: |- \
        \n      apiVersion: apps/v1 \
        \n      kind: Deployment \
        \n      metadata: \
        \n        name: $CI_PROJECT_NAME \
        \n      spec: \
        \n        template: \
        \n          metadata: \
        \n            annotations: \
        \n              git_tag: \"$GIT_TAG\" \
        \n              pipeline_timestamp: \"$CI_PIPELINE_CREATED_AT\" \
        \n              cluster_name: \"$CLUSTER_NAME\" \
        \n              build_env: \"$BUILD_ENV\" \
        \n              namespace_name: \"$NAMESPACE_NAME\" \
        \n" \
        \
        >> deploy/overlays/$BUILD_ENV/kustomization.yaml

      if [[ "$PIPELINE_DEBUG" == "true" ]]; then
        echo -e " \
          \n\e[31m##### Updated deployment patch file: #####\e[0m \
          \n"
        cat deploy/overlays/$BUILD_ENV/deployment.yaml
      fi

      echo -e " \
        \nDeployment patch info: \
        \n \
        \n  git_tag: $GIT_TAG \
        \n  pipeline_timestamp: $CI_PIPELINE_CREATED_AT \
        \n  cluster_name: $CLUSTER_NAME \
        \n  build_env: $BUILD_ENV \
        \n  namespace_name: $NAMESPACE_NAME \
        \n"


# Adds kustomizations to pull latest commit image for dev/staging
.kustomize_image:
  script:
    - |
      echo -e " \
        \nDeploy tag set to: $IMAGE_TAG \
        \n"

      echo -e " \
        \nimages: \
        \n  - name: $CI_PROJECT_NAME \
        \n    newName: $CI_REGISTRY_IMAGE \
        \n    newTag: $IMAGE_TAG \
        \n" \
        \
        >> deploy/overlays/$BUILD_ENV/kustomization.yaml

      echo -e " \
        \nImage patch added to kustomization \
        \n"

      if [[ "$PIPELINE_DEBUG" == "true" ]]; then
        echo -e " \
          \n\e[31m##### Patched kustomization file: #####\e[0m \
          \n"
        cat deploy/overlays/$BUILD_ENV/kustomization.yaml
      fi


# Adds annotations that link a deployment to GitLab's Environment/Operations dashboards
.add_common_annotations:
  script:
    - |
      echo -e " \
        \ncommonAnnotations: \
        \n  app.gitlab.com/app: $CI_PROJECT_PATH_SLUG \
        \n  app.gitlab.com/env: $CI_ENVIRONMENT_SLUG \
        \n" \
        \
        >> deploy/overlays/$BUILD_ENV/kustomization.yaml

      echo -e "\nCommon annotations added to kustomization"

      if [[ "$PIPELINE_DEBUG" == "true" ]]; then
        echo -e " \
          \n\e[31m##### Patched kustomization file: #####\e[0m \
          \n"
        cat deploy/overlays/$BUILD_ENV/kustomization.yaml
      fi


# Patches `ingress.yaml`
# Dev target URL:
#   - https://{CI_PROJECT_NAME}.{CLUSTER_NAME}.reviews.dev.ltc.bcit.ca/{CI_COMMIT_REF_SLUG}
#     eg. https://qcon-api.dev-cp.reviews.dev.ltc.bcit.ca/189-fix-tls
#
# Staging target URL: 
  # - https://latest.dev.ltc.bcit.ca/{CI_PROJECT_NAME}
  #   eg. https://latest.dev.ltc.bcit.ca/qcon-api
#
# Prod target URLs:
# Default
  # - https://stable.dev.ltc.bcit.ca/{CI_PROJECT_NAME}
  #   eg. https://stable.dev.ltc.bcit.ca/qcon-api
#
# Extra (not yet implemented)
  # - https://{PROD_NAMESPACE}.ltc.bcit.ca/
  #   eg. https://qcon-api.ltc.bcit.ca
#
.patch_ingress:
  script:
    - |
      if [[ "$BUILD_ENV" == "staging" ]] || [[ "$BUILD_ENV" == "prod" ]]; then

        echo -e " \
          \napiVersion: networking.k8s.io/v1 \
          \nkind: Ingress \
          \nmetadata: \
          \n  name: $CI_PROJECT_NAME-ingress \
          \n  annotations: \
          \n    nginx.ingress.kubernetes.io/configuration-snippet: \
          \n      rewrite ($CI_PROJECT_NAME)$ $CI_PROJECT_NAME/ redirect; \
          \n      rewrite ^/($CI_PROJECT_NAME)/(.*) /\$2 break; \
          \nspec: \
          \n  tls: \
          \n    - hosts: \
          \n      - $CI_HOST \
          \n      secretName: $TLS_SECRET_NAME \
          \n  rules: \
          \n    - host: $CI_HOST \
          \n      http: \
          \n        paths: \
          \n        - path: /$CI_PROJECT_NAME \
          \n          pathType: Prefix \
          \n          backend: \
          \n            service: \
          \n              name: $CI_PROJECT_NAME \
          \n              port: \
          \n                number: $APP_PORT \
          \n" \
          \
          > deploy/overlays/$BUILD_ENV/ingress.yaml
      
      else

        echo -e " \
          \napiVersion: networking.k8s.io/v1 \
          \nkind: Ingress \
          \nmetadata: \
          \n  name: $CI_PROJECT_NAME-ingress \
          \n  annotations: \
          \n    nginx.ingress.kubernetes.io/configuration-snippet: \
          \n      rewrite ($NAMESPACE_NAME)$ $NAMESPACE_NAME/ redirect; \
          \n      rewrite ^/($NAMESPACE_NAME)/(.*) /\$2 break; \
          \nspec: \
          \n  rules: \
          \n    - host: $CI_PROJECT_NAME.$CLUSTER_NAME.$CI_HOST \
          \n      http: \
          \n        paths: \
          \n          - path: /$NAMESPACE_NAME \
          \n            pathType: Prefix \
          \n            backend: \
          \n              service: \
          \n                name: $CI_PROJECT_NAME \
          \n                port: \
          \n                  number: $APP_PORT \
          \n" \
          \
          > deploy/overlays/$BUILD_ENV/ingress.yaml      
      fi

      echo -e " \
        \nIngress resource replaced with $BUILD_ENV kustomization \
        \n"
      
      if [[ "$PIPELINE_DEBUG" == "true" ]]; then
        echo -e " \
          \n\e[31m##### Updated ingress file: #####\e[0m \
          \n"
        cat deploy/overlays/$BUILD_ENV/ingress.yaml
      fi

# Creates tls secret for ingress via Kustomize secretGenerator
.create_tls_secret:
  script:
    - |
      echo "$TLS_CRT" | base64 --decode > deploy/overlays/$BUILD_ENV/tls.crt
      echo "$TLS_KEY" | base64 --decode > deploy/overlays/$BUILD_ENV/tls.key

      echo -e "\nData files for TLS secret generation created successfully"


# DEBUG TRACE HELPER (enable in main pipeline): Validates kustomizations
.verify_kustomization:
  script:
    - |
      if [[ "$PIPELINE_DEBUG" == "true" ]]; then
        echo -e " \
          \n\e[31m##### Patched kustomization file: #####\e[0m \
          \n"
        cat deploy/overlays/$BUILD_ENV/kustomization.yaml
        echo -e " \
          \n\e[31m##### Kustomized resources being applied to cluster: #####\e[0m \
          \n"
        kubectl kustomize deploy/overlays/$BUILD_ENV
      fi


# Common Tags and Rules for jobs
.feature_branch_rules:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "release"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_MERGE_REQUEST_EVENT_TYPE == "detached"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_OPEN_MERGE_REQUESTS'
  tags:
    - $CLUSTER_NAME

.main_branch_rules:
  rules:
    - if: '$CI_COMMIT_REF_SLUG == "main" && $CI_PIPELINE_SOURCE == "push"'
  tags:
    - staging

.semver_tag_rules:
  rules:
    - if: '$CI_COMMIT_REF_SLUG == "release" && $CI_PIPELINE_SOURCE == "push"'
  tags:
    - production

.release_branch_rules:
  rules:
    - if: $CI_COMMIT_TAG
  tags:
    - production